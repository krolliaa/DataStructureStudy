# `Tree`

树这种数据结构可以提高数据的存储和读取效率，比如二叉排序树既可以保证数据的检索速度又可以保证数据的插入、删除和修改的速度。

常用相关术语：节点、根节点、父节点、子节点 、叶子结点（没有子节点的节点）、节点的权（节点的值）、路径（从`root`节点找到该节点的路径）、层、子树、树的高度（最大层数）、森林：多颗子树构成森林

## 1. `BinaryTree`

- 二叉树就是每个节点最多只能有两个节点的形式的树称为二叉树
- 二叉树的子节点，分为左节点和右节点
- 满二叉树：所有的叶子节点都在最后一层
- 完全二叉树：所有的叶子节点在最后一层或者倒数第二层连续，比如在有两个叶子节点在最后一层左边连续，有三个叶子节点在倒数第二层右边连续，那这就叫做完全二叉树，如果少了一个节点都不叫完全二叉树，也不叫满二叉树，就是一棵二叉树

下面是二叉树的示意图，其中第一幅图不仅是二叉树还是一种特殊的二叉树叫做满二叉树【所有叶子节点都在最后一层】，总节点个数为`2^n-1`个：

![](https://img-blog.csdnimg.cn/540f7c9e4793409682b6d5b219e742ff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_19,color_FFFFFF,t_70,g_se,x_16)

二叉树的遍历有，序是针对父节点而言的：

1. 前序遍历：先输出父节点，再遍历左子树和右子树

2. 中序遍历：先遍历左子树，再输出父节点，最后遍历右子树

3. 后序遍历：先遍历右子树，再遍历左子树，最后输出父节点

   创建节点并且打造遍历方法【采用递归，也是比较好理解的】：

   ```java
   package main;
   
   public class D09HeroNode {
       //用于模拟二叉树节点
       private int no;
       private String name;
       private D09HeroNode left;
       private D09HeroNode right;
   
       public D09HeroNode(int no, String name) {
           this.no = no;
           this.name = name;
       }
   
       public int getNo() {
           return no;
       }
   
       public void setNo(int no) {
           this.no = no;
       }
   
       public String getName() {
           return name;
       }
   
       public void setName(String name) {
           this.name = name;
       }
   
       public D09HeroNode getLeft() {
           return left;
       }
   
       public void setLeft(D09HeroNode left) {
           this.left = left;
       }
   
       public D09HeroNode getRight() {
           return right;
       }
   
       public void setRight(D09HeroNode right) {
           this.right = right;
       }
   
       @Override
       public String toString() {
           return "D09HeroNode{" +
                   "no=" + no +
                   ", name='" + name + '\'' +
                   ", left=" + left +
                   ", right=" + right +
                   '}';
       }
   
       //前序遍历
       public void preOrder() {
           System.out.print("[" + this.getNo() + " " + this.getName() + "] ");
           if (this.left != null) this.left.preOrder();
           if (this.right != null) this.right.preOrder();
       }
   
       //中序遍历
       public void infixOrder() {
           if (this.left != null) this.left.infixOrder();
           System.out.print("[" + this.getNo() + " " + this.getName() + "] ");
           if (this.right != null) this.right.infixOrder();
       }
   
       //后序遍历
       public void postOrder() {
           if (this.left != null) this.left.postOrder();
           if (this.right != null) this.right.postOrder();
           System.out.print("[" + this.getNo() + " " + this.getName() + "] ");
       }
   }
   ```

   ```java
   package main;
   
   public class D09BinaryTree {
       private D09HeroNode root;
   
       public D09BinaryTree(D09HeroNode root) {
           this.root = root;
       }
   
       //前序遍历
       public void preOrder() {
           if (root == null) {
               System.out.println("二叉树是空的...");
               return;
           }
           System.out.print("前序遍历：");
           this.root.preOrder();
           System.out.println();
       }
   
       //中序遍历
       public void infixOrder() {
           if (root == null) {
               System.out.println("二叉树是空的...");
               return;
           }
           System.out.print("中序遍历：");
           this.root.infixOrder();
           System.out.println();
       }
   
       //后序遍历
       public void postOrder() {
           if (root == null) {
               System.out.println("二叉树是空的...");
               return;
           }
           System.out.print("后序遍历：");
           this.root.postOrder();
           System.out.println();
       }
   }
   ```

   测试：

   ```java
   package main;
   
   public class D09BinaryTreeDemo {
       public static void main(String[] args) {
           D09HeroNode root = new D09HeroNode(1, "宋江");
           D09HeroNode node2 = new D09HeroNode(2, "吴用");
           D09HeroNode node3 = new D09HeroNode(3, "卢俊义");
           D09HeroNode node4 = new D09HeroNode(4, "林冲");
           D09HeroNode node5 = new D09HeroNode(5, "关胜");
           root.setLeft(node2);
           root.setRight(node3);
           node3.setLeft(node5);
           node3.setRight(node4);
           D09BinaryTree binaryTree = new D09BinaryTree(root);
           //前序遍历
           binaryTree.preOrder();
           //中序遍历
           binaryTree.infixOrder();
           //后序遍历
           binaryTree.postOrder();
       }
   }
   ```

前序遍历查找节点【递归】：

```java
    //前序遍历查找数值
    public D09HeroNode findByPreOrder(int no) {
        if (this.no == no) return this;
        D09HeroNode findNode = null;
        if (this.left != null) findNode = this.left.findByPreOrder(no);
        if (findNode != null) return findNode;
        if (this.right != null) findNode = this.right.findByPreOrder(no);
        return findNode;
    }
```

中序遍历查找节点【递归】：

```java
	//中序遍历查找数值
    public D09HeroNode findByInfixOrder(int no) {
        D09HeroNode findNode = null;
        if (this.left != null) findNode = this.left.findByInfixOrder(no);
        if (findNode != null) return findNode;
        if (this.no == no) return this;
        if (this.right != null) findNode = this.right.findByInfixOrder(no);
        return findNode;
    }
```

后序遍历查找节点【递归】：

```java
	//后序遍历查找数值
    public D09HeroNode findByPostOrder(int no) {
        D09HeroNode findNode = null;
        if (this.left != null) findNode = this.left.findByPostOrder(no);
        if (findNode != null) return findNode;
        if (this.right != null) findNode = this.right.findByPostOrder(no);
        if (findNode != null) return findNode;
        if (this.no == no) return this;
        return null;
    }
```

删除节点：[这里是删除一整块的节点，如何只单方面删除一个节点，然后把其它节点接到上面去？---> 见二叉排序树]

- 如果删除的是叶子节点，直接删除
- 如果是删除的是非叶子节点，直接删除该树
- 因为该二叉树是单向的，删除的操作类似于单向链表的删除，所以需要获取要删除节点的上一个节点才可以

```java
	//删除操作
    public void deleteHero(int no) {
        if (this.left != null && this.left.no == no) {
            this.left = null;
            return;
        }
        if (this.right != null && this.right.no == no) {
            this.right = null;
            return;
        }
        if (this.left != null) this.left.deleteHero(no);
        if (this.right != null) this.right.deleteHero(no);
    }
```

## 2. `ArrayBinaryTree`

从数据存储方式来看，树的存储方式和数组的存储方式是可以互换的即数组可以转换成树，树也可以转换成数组。将二叉树转换成数组一般是有规则的，规则如下：

- 顺序存储二叉树通常只考虑完全二叉树
- 在数组中的第 `n` [相当于下标]个元素的左子节点为：`2 * n + 1`
- 在数组中的第 `n` [相当于下标]个元素的右子节点为：`2 * n + 2`
- 在数组中的第 `n` [相当于下标]个元素的父节点为：`(n - 1) / 2`

```java
package main;

public class D09ArrayBinaryTree {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(arr);
        //前序遍历得到：1 2 4 8 9 5 3 6 7
        System.out.print("前序遍历：");
        arrayBinaryTree.preOrder(0);
        System.out.println();
        //中序遍历得到：8 4 9 2 5 1 6 3 7
        System.out.print("中序遍历：");
        arrayBinaryTree.infixOrder(0);
        System.out.println();
        //后序遍历得到：8 9 4 5 2 6 7 3 1
        System.out.print("后序遍历：");
        arrayBinaryTree.postOrder(0);
        System.out.println();
    }
}

class ArrayBinaryTree {
    private int[] arr = null;

    public ArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }

    //前序遍历
    public void preOrder(int index) {
        //如果 arr 为空返回
        if (arr == null && arr.length == 0) {
            System.out.println("完全二叉树为空哦~");
            return;
        }
        System.out.print(arr[index] + " ");
        //向左子树遍历
        if ((index * 2 + 1) < arr.length) preOrder(2 * index + 1);
        //向右子树遍历
        if ((index * 2 + 2) < arr.length) preOrder(2 * index + 2);
    }

    //中序遍历
    public void infixOrder(int index) {
        //如果 arr 为空返回
        if (arr == null && arr.length == 0) {
            System.out.println("完全二叉树为空哦~");
            return;
        }
        if ((index * 2 + 1) < arr.length) infixOrder(index * 2 + 1);
        System.out.print(arr[index] + " ");
        if ((index * 2 + 2) < arr.length) infixOrder(index * 2 + 2);
    }

    //后序遍历
    public void postOrder(int index) {
        //如果 arr 为空返回
        if (arr == null && arr.length == 0) {
            System.out.println("完全二叉树为空哦~");
            return;
        }
        if ((index * 2 + 1) < arr.length) postOrder(index * 2 + 1);
        if ((index * 2 + 2) < arr.length) postOrder(index * 2 + 2);
        System.out.print(arr[index] + " ");
    }
}
```

## 3. `ThreadBinaryTree`

构成线索二叉树的前提条件就是该二叉树是一棵完全二叉树，假设有`n`个节点，则一共有`2n`个链域，以为除了根节点是没有父节点的，其它的节点都有父节点，所以肯定有`n-1`非空链域，所以空链域一共有：`2n-(n-1) = n+1`个，构造线索二叉树跟原完全二叉树的遍历方式有关，比如这里有一棵二叉树，中序遍历的结果为：`[8, 3, 10, 1, 14, 6]`，前序遍历的结果为：`[1, 3, 8, 10, 6, 14]`可以看到前驱结点和后继节点是不一样的。

这里以中序遍历的结果：`[8, 3, 10, 1, 14, 6]`做一个构造线索二叉树的例子：

- `8`没有前驱结点，所以左指针不指向任何节点，但是有后继节点`3`，所以`8`的右指针指向`3`
- `3`因为左指针和右指针都被占据了，所以即使有前驱结点和后继节点也不指向
- `10`有前驱结点`3`所以左指针指向`3`，后继节点`1`所以右指针指向`1`
- `1`同`3`一样的处境，左右指针都被占据了
- `14`有前驱结点`1`所以左指针指向`1`，后继节点`6`所以右指针指向`6`
- `6`有左指针，同时也是前驱节点，指向`14`，无后继节点所以右指针不指向任何节点

【注：无论左指针还是右指针，指向的节点可能是子树，也可能是前驱结点或者后继节点】

![](https://img-blog.csdnimg.cn/09a6ac1a8ef842739ee7f15374fdd226.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16)

让我们看一张更加直观的图，该图是在某博客上看到的，看到时觉得非常直观，视觉感极佳：

![](https://img-blog.csdn.net/20170107163208797?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVW5jbGVNaW5nNTM3MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

线索化二叉树的代码，最最核心的就是`previousNode`的后继节点的解法，整个算法首先需要遍历左子树直到第一个节点【因为这是中序遍历】，然后开始判断是否可以接前驱结点和后继节点，前驱节点就是按照常规思路，判断左指针是否为空为空就接上`previousNode`。

但是就是后驱节点不好接，因为那时候你是不知道后驱节点是哪个的，只有当真正到大下一个节点的时候，你才知道：”噢~~原来之前的那个节点的后继节点就是这个“，但是之前那个节点已经成了前驱节点了，所以需要拿`previousNode`来做，如果`previousNode != null`也就是上一个节点是存在的并且上一个节点的右指针为空`previousNode.getRight() == null`的时候才可以接后驱节点，这个是最最核心的地方，然后将当前这个节点赋值为`previousNode`变成了前驱结点。

最后继续判断右子树即可。

```java
	//采用中序遍历线索化二叉树
    public void threadedNodes(D09ThreadNode threadNode) {
        if (threadNode == null) return;
        //中序遍历，需要到最后一个左节点
        if (threadNode.getLeft() != null) threadedNodes(threadNode.getLeft());
        //到达此处已经遍历到左子树，如果左子节点为空表示可以接前驱结点，并设置 leftType 为 1
        if (threadNode.getLeft() == null) {
            threadNode.setLeft(previousNode);
            threadNode.setLeftType(1);
        }
        //因为右指针接的是后继节点，直接接接不了后驱节点，只能当自己作为前驱节点的时候，下一个节点【即当前节点】的时候就可以作为后继节点接入
        //需要判断上一个节点不为 null
        if (previousNode != null && previousNode.getRight() == null) {
            previousNode.setRight(threadNode);
            previousNode.setRightType(1);
        }
        //下一个节点，需要设置当前节点为前驱节点
        previousNode = threadNode;
        //线索化右子树
        if (threadNode.getRight() != null) threadedNodes(threadNode.getRight());
    }
```

遍历线索二叉树：

```java
public void threadList() {
    //中序线性链表所以得到的是中序遍历的结果
    D09ThreadNode currentNode = root;
    while(currentNode != null) {
        //遍历到第一个有空链域的节点
        while(currentNode.getLeftType() == 0) currentNode = currentNode.getLeft();
        //打印该节点信息
        System.out.print("[" + currentNode.getNo() + ", " + currentNode.getName() + "] ---> ");
        //往后继节点遍历
        while(currentNode.getRightType() == 1) {
            //到下一个后继节点
            currentNode = currentNode.getRight();
            //打印该节点
            System.out.print("[" + currentNode.getNo() + ", " + currentNode.getName() + "] ---> ");
        }
        //到这里说明已经不是空链域节点了，右指针指向非空链域的节点，手动到达右边，可能为 null，由 while 来判断
        currentNode = currentNode.getRight();
    }
}
```

上述是中序线索化二叉树，还可以实行前序线索化二叉树和后序线索化二叉树，前序线索化二叉树如下，跟中序遍历还是稍微有点不同的，因为前序遍历是可能会形成循环的，为了避免循环需要加入判断条件：

```java
public void preThreadedNodes(D09ThreadNode threadNode) {
    //判断该节点是否为空，为空就返回
    if(threadNode == null) return;
    //只有当左节点为空的时候才赋值 previousNode 节点
    if(threadNode.getLeft == null) {
        threadNode.setLeft(previousNode);
        threadNode.setLeftType(1);
    }
    //只有当右节点为空的时候才赋值，并且因为没有 nextNode 这种节点，只有 previousNode 所以需要到下一个节点再赋值，值为当前节点
    if(previousNode != null && previousNode.getRight == null) {
        previousNode.setRight(threadNode);
        previousNode.setRightType(1);
    }
    previousNode = threadNode;
    //只有当左节点的类型不是前驱结点的时候才继续遍历，否则略过
	if(threadNode.getLeftType() == 0 && threadNode.getLeft() != null) preThreadedNodes(threadNode.getLeft());
    //只有当右节点的类型不是后继节点的时候才继续遍历，否则略过
	if(threadNode.getRightType() == 0 && threadNode.getRight() != null) preThreadedNodes(threadNode.getRight());
}
```

下列为后序线索化二叉树：

```java
public void postThreadedNodes(D09ThreadNode threadNode) {
    //如果当前节点为空直接略过
    if(threadNode == null) return;
	//只有当左节点不是前驱结点的时候才继续遍历，否则略过
    if(threadNode.getLeftType() == 0 && threadNode.getLeft() != null) return;
	//只有当左节点不是前驱结点的时候才继续遍历，否则略过
    if(threadNode.getRightType() == 0 && threadNode.getRight() != null) return;
    //到这里开始线索化当前节点
    if(threadNode.getLeft() == null) {
        threadNode.setLeft(previous);
        threadNode.setLeftType(1);
    }
    if(previousNode != null && previousNode.getRight() == null) {
        threadNode.setRight(threadNode);
        threadNode.setRightType(1);
    }
    previousNode = threadNode;
}
```

当然也可以前序遍历线索化二叉树：

```java
	//前序遍历线索化二叉树
    public void preThreadList() {
        D09ThreadNode currentNode = root;
        while (currentNode != null) {
            while (currentNode.getLeftType() == 0) {
                System.out.print("[" + currentNode.getNo() + ", " + currentNode.getName() + "] ---> ");
                currentNode = currentNode.getLeft();
            }
            System.out.print("[" + currentNode.getNo() + ", " + currentNode.getName() + "] ---> ");
            currentNode = currentNode.getRight();
        }
    }
```

也可以后序遍历线索二叉树，后续遍历线索二叉树比前序和中序都要复杂，需要好好研究琢磨琢磨：

首先看一张图，这张图只给出了后驱节点，后序遍历为`[H I D E B F G C A]`：

![](https://img-blog.csdnimg.cn/80b5673f5d984db5b9c6518c65c12ca6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16)

我们脑洞模拟一遍，因为是后序遍历，所以从最左节点`H`出发，通过后驱可以找到I`I`，然后找到`D`，到这里就卡主了，怎么找到`E`呢？我们发现，想找到`E`，我们可以通过`B`，`B`是`E`的父节点，所以我们需要在节点类中增添一个属性，该属性就是父节点`private D09ThreadNode parent`并提供`setter getter`方法，`D`节点通过`getParent()`就可以获取到`B`节点，然后`B`节点通过`getRight()`方法就可以获取到`E`节点，然后`E`节点继续通过后驱就可以到`B`节点，但是之前已经通过`getParent()`获取到了`B`节点，什么时候打印，什么时候不打印呢？我们分两种情况来讨论：如果当前节点是上一个节点的`getRight()`方法可以得到的那说明就是遍历到父节点了，此时我们需要借助`previousNode`节点来帮助判断该条件，如果不是，将该节点赋值为有节点然后一直遍历到左节点【满足条件时才赋值找左节点】

```java
public void postList() {
    D09ThreadNode currentNode= root;
	D09ThreadNode previousNode = null;
    //获取最左节点
    while(currentNode.getLeftType() == 0 && currentNode.getLeft() != null) currentNode = currentNode.getLeft();
    while(currentNode != null) {
        //如果有后继节点
        if(currentNode.getRightType() == 1){
			System.out.print("[" + currentNode.getNo() + ", " + currentNode.getName() + "] ---> ");
            previousNode = currentNode;
            currentNode = currentNode.getRight();
        } else {
            //如果是从右节点过来，那么当前节点的右节点就是上一个节点
            if(currentNode.getRight() == previousNode) {
				System.out.print("[" + currentNode.getNo() + ", " + currentNode.getName() + "] ---> ");   
                if(currentNode == root) return;
                previousNode = currentNode;
                currentNode = currentNode.parent();
            } else{
				//如果不是，表明从左节点过来的
                currentNode = currentNode.getRight();
                while(currentNode.getLeftType() == 0 && currentNode.getLeft() != null) currentNode = currentNode.getLeft();
            }
		}
	}
}
```

## 4. `HuffmanBinaryTree`

哈夫曼树也叫最优二叉树，本质是拥有最小树的带权路径长度的树。

- 路径长度：通路中分支的数目叫做路径长度。每个节点的路径长度就是`层数-1`，比如第一个节点是根节点，那么它的路径长度就为`1 - 1 = 0`，根节点的左孩子节点的路径长度就为：`2 - 1 = 1`，这是路径。
- 带权路径长度：节点的数值就是该节点的权值，带权路径长度就是`权值 X 路径长度`，比如一个节点的权值为`13`且为根节点的左孩子节点，则带权路径长度为：`13 x 1 = 13`
- 树的带权路径长度：就是所有节点的带权路径长度之和，最小的就是哈夫曼树也叫最优二叉树。树的带权路径长度英文名为：`weighted path length`称为`WPL`，越小越优。

构造哈夫曼树过程：

1. 从小到大进行排序，每一个数据都是一个节，每个节点都看成是最简单的二叉树。
2. 取出根节点权值最小的两棵二叉树。
3. 组成一个新的二叉树，该二叉树的权值就是前面两棵二叉树权值的和。
4. 再将这棵二叉树以根节点的权值大小，再次排序，然后不断重复`1-4`步骤，直至所有的数据都被处理，就形成了哈夫曼树。![](https://img-blog.csdnimg.cn/c8a5d101f044493a8e453a46ba8cb07c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16)

利用集合`ArrayList`以及`Collections`的`sort`方法实现排序，我们可以很快的实现构造哈夫曼树的代码。

首先编写结点类`Nodes.java`：

```java
class Node implements Comparable<Node> {
    private int value;
    private Node leftNode;
    private Node rightNode;

    public Node(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public Node getLeftNode() {
        return leftNode;
    }

    public void setLeftNode(Node leftNode) {
        this.leftNode = leftNode;
    }

    public Node getRightNode() {
        return rightNode;
    }

    public void setRightNode(Node rightNode) {
        this.rightNode = rightNode;
    }

    @Override
    public String toString() {
        return "Node[" +
                "value=" + value +
                ']';
    }

    @Override
    public int compareTo(Node o) {
        return this.value - o.value;
    }

    //前序遍历
    public void preOrder() {
        System.out.print(this.getValue() + " ---> ");
        if (this.leftNode != null) this.leftNode.preOrder();
        if (this.rightNode != null) this.rightNode.preOrder();
    }
}
```

打造创建哈夫曼树的方法：

```java
	 //创建哈夫曼树
    public static Node createHuffmanTree(int[] huffman) {
        //创建集合，存放节点
        List<Node> list = new ArrayList<>();
        for (int value : huffman) list.add(new Node(value));
        while (list.size() > 1) {
            //1. 对集合中元素进行排序
            Collections.sort(list);
            //2. 取出集合中前两个节点作为左孩子节点和右孩子节点
            Node leftNode = list.get(0);
            Node rightNode = list.get(1);
            //3. 将左孩子结点和右孩子节点结合起来形成一个新的二叉树
            Node littleTree = new Node(leftNode.getValue() + rightNode.getValue());
            littleTree.setLeftNode(leftNode);
            littleTree.setRightNode(rightNode);
            //4. 删除刚刚的左孩子节点和右孩子节点，将 littleTree 放入集合中
            list.remove(leftNode);
            list.remove(rightNode);
            list.add(littleTree);
            //循环上述四个方法，直到集合中只剩下一棵二叉树
        }
        return list.get(0);
    }
```

测试：

```java
	public static void main(String[] args) {
        int huffman[] = {1, 6, 13, 7, 29, 8, 3};
        Node huffmanTree = createHuffmanTree(huffman);
        //前序遍历的结果为：67 29 38 15 7 8 23 10 4 1 3 6 13
        huffmanTree.preOrder();
    }
```

## 5. `HuffmanCode`

哈夫曼编码常用于数据文件压缩，压缩率在`20% ~ 90%`之间，哈夫曼编码是可变字长编码`(VLC)`的一种，哈夫曼编码是一种无损处理方案。

核心思路：找到要传输的数据统计各个字符在这串要传输的数据出现的次数，作为权值然后根据这些权值构造一棵哈夫曼树，根据哈夫曼树对各个字符进行编码。然后依次得到各个字符的编码，向左为`0`，向右为`1`。

![](https://img-blog.csdnimg.cn/cb06fdd4cfcf43ed8d23c2d0676b79aa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_20,color_FFFFFF,t_70,g_se,x_16)

## 6. `BianrySortTree`

二叉排序树结合了数组和链表的优点，既可以快速地查找出数据也可以快速地对数据进行添加、修改和删除，是比较好的一种数据结构的选择。二叉排序树也叫二叉搜索树或者二叉查找树。

创建二叉排序树：

```java
	//创建二叉排序树
	public void add(SortNode sortNode) {
        //如果要添加的节点为空，直接返回
        if (sortNode == null) return;
        //比较要添加节点的值和当前节点的值，如果小于当前节点，放在左边
        if (this.getValue() > sortNode.getValue()) {
            //如果左节点为空，则插入，如果不为空，则递归
            if (this.getLeftNode() == null) this.leftNode = sortNode;
            else this.getLeftNode().add(sortNode);
        } else {
            //如果大于等于当前值且右节点为空则放在右边
            if (this.getRightNode() == null) this.rightNode = sortNode;
            else this.getRightNode().add(sortNode);
        }
    }
```

中序遍历：

```java
	//中序遍历
    public void infixOrder() {
        if(this.getLeftNode() != null) this.getLeftNode().infixOrder();
        System.out.print("[" + this.getValue() + "] ---> ");
        if(this.getRightNode() != null) this.getRightNode().infixOrder();
    }
```

删除结点【以`1 2 3 5 7 9 10 12`】：

1. 删除叶子结点，如【`2 5 9 12`】
2. 删除只有一个子树的结点：如【`1`】
3. 删除有两个子树的结点：如【7 3 10】

查找要删除结点的父结点：

```java
	//查询要删除结点的父结点
    public SortNode searchParent(int value) {
        //如果当前节点的左孩子或者右孩子结点的值与 value 相等，返回当前节点
        if ((value == this.getLeftNode().getValue() && this.getLeftNode() != null) || (value == this.getRightNode().getValue() && this.getRightNode() != null))
            return this;
        //否则的话比较 value 当前结点值看是往左边去还是往右边去
        if (value < this.getValue() && this.getLeftNode() != null) return this.getLeftNode().searchParent(value);
        else if (value > this.getValue() && this.getRightNode() != null) return this.getRightNode().searchParent(value);
        else return null;
    }
```

查找要删除的结点：

```java
	//查询指定值的结点
    public SortNode search(int value) {
        //如果当前结点的值等于指定值 value 然后返回
        if (value == this.value) return this;
        //如果 value 比当前节点的值要小就往左边找
        if (value < this.value) {
            //如果左节点不为空就找，为空直接返回 null
            if (this.getLeftNode() == null) return null;
            else return this.getLeftNode().search(value);
        } else {
            //如果 value 比当前节点的值要大就往右边找
            if (this.getRightNode() == null) return null;
            else return this.getRightNode().search(value);
        }
    }
```

创建一个二叉排序树的类：

```java
class BinarySortTree {
    private SortNode root;

    public BinarySortTree(SortNode root) {
        this.root = root;
    }

    //创建二叉排序树
    public void add(SortNode newNode) {
        root.add(newNode);
    }

    //中序遍历二叉排序树
    public void infixOrder() {
        root.infixOrder();
        System.out.print("null\n");
    }

    //查找 value 值的结点
    public void search(int value) {
        if (root == null) {
            System.out.println("二叉排序树为空~");
            return;
        }
        SortNode searchNode = root.search(value);
        if (searchNode != null) System.out.println("查找到的节点为：" + searchNode.toString());
        else System.out.println("没有找到该值的结点~");
    }

    //查找 value 值的父结点
    public void searchParent(int value) {
        if (root == null) {
            System.out.println("二叉排序树为空~");
            return;
        }
        if (value == root.getValue()) {
            System.out.println("该值所在结点为根节点没有父结点~");
            return;
        }
        SortNode searchNode = root.searchParent(value);
        if (searchNode != null) System.out.println("查找到的父节点为：" + searchNode.toString());
        else System.out.println("没有找到该值的父结点~");
    }
}
```

在该类上增添方法 ---> 删除结点：删除有两棵子树的结点有两种方法一种是找到右子节点的最小值，另外一种是找到左子节点的最大值，然后保存这个值并且删除该节点，最后将目标删除结点的值和该结点的值进行交换即可。

```java
	//删除结点
    public void deleteSortNode(int value) {
        //判断二叉排序树是否为空
        if (root == null) {
            System.out.println("二叉排序树为空，无法删除结点~");
            return;
        }
        //判断是否只有一个结点且根节点的值就是要删除的值
        if (value == root.getValue() && root.getLeftNode() == null && root.getRightNode() == null) {
            System.out.println("删除成功！");
            root = null;
            return;
        }
        //找到要删除的结点
        SortNode targetNode = root.search(value);
        //如果要删除的结点为空无法删除
        if (targetNode == null) {
            System.out.println("二叉排序树中没有等于该值的结点，无法删除！");
            return;
        }
        //找到要删除的结点的父节点
        SortNode targetNodeParent = root.searchParent(value);
        //第一种情况：要删除的结点是一个叶子节点
        if (targetNode.getLeftNode() == null && targetNode.getRightNode() == null) {
            //第一种情况的细分：判断要删除的结点是父结点的左孩子还是右孩子
            if (targetNodeParent.getLeftNode() != null && value == targetNodeParent.getLeftNode().getValue())
                targetNodeParent.setLeftNode(null);
            else if (targetNodeParent.getRightNode() != null && value == targetNodeParent.getRightNode().getValue())
                targetNodeParent.setRightNode(null);
        }
        //第二种情况：要删除的节点有两棵子树
        else if (targetNode.getLeftNode() != null && targetNode.getRightNode() != null) {
            //为了满足删除后不影响有序，可以获取右子树最小结点的值将其赋予到要删除的结点上即可
            int minValue = delMinRightNode(targetNode.getRightNode());
            targetNode.setValue(minValue);
        } else {
            //第三种情况：要删除的节点有一棵子树
            //需要考虑是否为根节点的情况，如果是根节点那么父节点则为空，如果不是根节点则不为空
            //前面已经判断过了：要删除的节点是叶子节点 + 要删除的节点有两棵子树，所以只剩下只有一棵子树的情况了
            //如果要删除的节点左子树不为空，说明只有左子树这一棵子树，再接着判断要删除的节点在父节点的左边还是右边
            if (targetNode.getLeftNode() != null) {
                //如果父节点存在
                if (targetNodeParent != null) {
                    if (targetNodeParent.getLeftNode().getValue() == value)
                        targetNodeParent.setLeftNode(targetNode.getLeftNode());
                        //如果要删除的节点在父节点的右边
                    else targetNodeParent.setRightNode(targetNode.getLeftNode());
                } else {
                    root = targetNode.getLeftNode();
                }
            } else {
                //如果父节点存在
                if (targetNodeParent != null) {
                    //否则就是要删除的节点右子树不为空
                    if (targetNodeParent.getLeftNode().getValue() == value)
                        targetNodeParent.setLeftNode(targetNode.getRightNode());
                        //如果要删除的节点在父节点的右边
                    else targetNodeParent.setRightNode(targetNode.getRightNode());
                } else {
                    root = targetNode.getRightNode();
                }
            }
        }
    }

    //获取右子树的最小结点值，并将最小结点删除
    public int delMinRightNode(SortNode currentNode) {
        System.out.println(currentNode.toString());
        while (currentNode.getLeftNode() != null) {
            currentNode = currentNode.getLeftNode();
        }
        int value = currentNode.getValue();
        deleteSortNode(value);
        return value;
    }

	//获取左子树最大的结点值，并将最大结点删除
    public int delMaxLeftNode(SortNode currentNode) {
        while (currentNode.getRightNode() != null) currentNode = currentNode.getRightNode();
        int value = currentNode.getValue();
        deleteSortNode(value);
        return value;
    }
```

## 7. `BalanceBinaryTree`

平衡二叉树也叫平衡二叉搜索树，简称`AVL`树，可以保证查询效率高。平衡二叉树即`AVL`树是基于二叉排序树的，否则无意义，因为它正是用来解决如果节点都在一个指针指向的这样就形成了单链表，众所周知，单链表的查询效率是很低的，所以为了解决这个问题，延伸除了二叉平衡树。

平衡二叉树具有以下特点：

1. 它是一棵空树或者左右两棵子树的高度差不大于`1`
2. 左右两棵子树都是一棵平衡二叉树
3. 如果高度差大于`1`则需要进行左旋或者右旋甚至双旋

构造一个方法获取当前结点的高度：

```java
public int height() {
    return Math.max(this.left == null ? 0 : return this.left.height(), this.right == null ? 0 : return this.right.height()) + 1;
}
```

获取左子树和右子树的高度从而获取高度差，如果左子树和右子树的高度差大于`1`，判断一下然后进行左旋或者右旋从而获取平衡二叉树即`AVL`树，左旋的步骤如下：

1. 创建一个`新结点`，将`当前结点`的值赋值给`新结点` ---> `AVLNode newNode = new AVLNode(root.value)`
2. `新结点`的左指针指向`当前结点`的左子树 ---> `newNode.left = root.left`
3. `新结点`的右指针指向`当前结点`的`右子结点`的左子树 ---> `newNode.right = root.right.left`
4. `右子结点`的值赋值给`当前结点` ---> `root.value = root.right.value`
5. `当前结点`的右指针指向`右子结点`的右子树 ---> `root.right = root.right.right`
6. `当前结点`的左指针指向`新结点` ---> `root.left = newNode`

```java
    //左旋
    public void leftRotate() {
        //1. 与根结点值一样的新结点
        AVLNode newNode = new AVLNode(root.getValue());
        //2. 新结点的左指针指向根结点的左子树
        newNode.setLeftNode(root.getLeftNode());
        //3. 新结点的右指针指向根结点的右子结点的左子树
        newNode.setRightNode(root.getRightNode().getLeftNode());
        //4. 根结点的值赋值为根结点的右子结点的值
        root.setValue(root.getRightNode().getValue());
        //5. 根结点的右指针指向右子节点的右子树
        root.setRightNode(root.getRightNode().getRightNode());
        //6. 根结点的左指针指向新结点
        root.setLeftNode(newNode);
    }
```

右旋步骤如下：

1. 创建一个新结点，将根结点的值赋值给新结点 ---> `AVLNode newNode = new AVLNode(root.value)`
2. 新结点的右指针指向根结点的右子树 ---> `newNode.right = root.right`
3. 新结点的左指针指向根结点的左子结点的右子树 ---> `newNode.left = root.left.right`
4. 根结点的左子节点的值赋值给根结点 ---> `root.left.value = root.value`
5. 根结点的左指针指向左子节点的左子节点 ---> `root.left = root.left.left`
6. 根结点的右指针指向新结点 ---> `root.right = newNode`

```java
    //右旋
    public void rightRotate() {
        //1. 创建一个新结点并赋值为根结点的值
        AVLNode newNode = new AVLNode(root.getValue());
        //2. 新结点的右指针指向根结点的右子树
        newNode.setRightNode(root.getRightNode());
        //3. 新结点的左指针指向根结点的左子节点的右子树
        newNode.setLeftNode(root.getLeftNode().getRightNode());
        //4. 左子结点的值赋值给根结点
        root.setValue(root.getLeftNode().getValue());
        //5.根结点的左指针指向左子节点的左子树
        root.setLeftNode(root.getLeftNode().getLeftNode());
        //6. 根结点的右指针指向新结点
        root.setRightNode(newNode);
    }
```

有些情况进行单独的左旋和右旋都是无法，这种情况有，此时要进行双旋：

1. 如果确定了要左旋即`rightHeight - leftHeight > 1`时，但是此时右子节点的左子树的高度`>`右子节点的右子树的高度则需要先将根结点的右子树右旋然后再对整棵树进行左旋，比如：`[10, 7, 11, 6, 8, 9]`
2. 如果确定了要右旋即`leftHeight - rightHeight > 1`时，但是此时左子节点的右子树的高度`>`左子节点的左子树的高度则需要先将根结点的左子树左旋然后再对整棵树进行右旋，比如：`[2, 1, 6, 5, 7, 3]`

大总结 —— 创建平衡二叉树：

```java
    //创建平衡二叉树
    public void createAVLTree() {
        //获取根结点的左子树高度
        int rootLeftHeight = root.getLeftNode().height();
        //获取根结点的右子树高度
        int rootRightHeight = root.getRightNode().height();
        //判断是左旋还是需要右旋还是不需要旋转
        int height = rootLeftHeight - rootRightHeight;
        //如果高度差小于 -1 表明右子树高度大且高度差 > 1，进行左旋
        if (height < -1) {
            //确定左旋判断是否需要双旋 ---> 右子结点的左子树的高度 > 右子树的高度 ---> 进行右旋
            int rootRightLeftHeight = 0;
            int rootRightRightHeight = 0;
            if (root.getRightNode().getLeftNode() != null)
                rootRightLeftHeight = root.getRightNode().getLeftNode().height();
            if (root.getRightNode().getRightNode() != null)
                rootRightRightHeight = root.getRightNode().getRightNode().height();
            //此时需要做双旋
            if (rootRightLeftHeight > rootRightRightHeight) root.doubleLeftRotate();
                //否则做左旋即可
            else root.leftRotate();
            System.out.println("树的高度：" + rootTreeHeight());
            System.out.println("左子树的高度：" + leftTreeHeight());
            System.out.println("右子树的高度：" + rightTreeHeight());
        }
        //如果高度差大于 1 表明左子树高度大且高度差 > 1，进行右旋
        else if (height > 1) {
            //确定右旋判断是否需要双旋 ---> 左子结点的右子树的高度 > 左子树的高度 ---> 进行左旋
            int rootLeftRightHeight = 0;
            int rootLeftLeftHeight = 0;
            if (root.getLeftNode().getRightNode() != null)
                rootLeftRightHeight = root.getLeftNode().getRightNode().height();
            if (root.getLeftNode().getLeftNode() != null)
                rootLeftLeftHeight = root.getLeftNode().getLeftNode().height();
            //此时需要做双旋
            if (rootLeftRightHeight > rootLeftLeftHeight) root.doubleRightRotate();
                //否则做右旋即可
            else root.rightRotate();
            System.out.println("树的高度：" + rootTreeHeight());
            System.out.println("左子树的高度：" + leftTreeHeight());
            System.out.println("右子树的高度：" + rightTreeHeight());
        }
        //不进行旋转
        else {
            //否则高度差不大于 1 不用进行旋转，本身就是平衡二叉树
            System.out.println("该二叉排序树本身就是一个平衡二叉树哦~");
            return;
        }
    }
```

全部代码如下：

```java
package main;

public class D10AVLTree {
    public static void main(String[] args) {
        //测试左旋：int arr[] = {4, 3, 6, 5, 7, 8};
        //测试右旋：int arr[] = {6, 5, 8, 3, 2, 4};
        //测试双旋 ---> 先左后右：int arr[] = {10, 7, 11, 6, 8, 9};
        //测试双旋 ---> 先右后左：int arr[] = {2, 1, 6, 5, 3, 7};
        int arr[] = {2, 1, 6, 5, 7, 3};
        AVLNode root = new AVLNode(2);
        AVLTree avlTree = new AVLTree(root);
        for (int i = 1; i < arr.length; i++) avlTree.add(new AVLNode(arr[i]));
        System.out.println("创建平衡二叉树之前的高度：");
        System.out.println("树的高度：" + avlTree.rootTreeHeight());
        System.out.println("左子树的高度：" + avlTree.leftTreeHeight());
        System.out.println("右子树的高度：" + avlTree.rightTreeHeight());
        System.out.println("平衡二叉树之后的高度：");
        avlTree.createAVLTree();
        avlTree.infixOrder();
    }
}

class AVLTree {
    private AVLNode root;

    public AVLTree(AVLNode root) {
        this.root = root;
    }

    //创建二叉排序树
    public void add(AVLNode newNode) {
        root.add(newNode);
    }

    //中序遍历二叉排序树
    public void infixOrder() {
        root.infixOrder();
        System.out.print("null\n");
    }

    //创建平衡二叉树
    public void createAVLTree() {
        //获取根结点的左子树高度
        int rootLeftHeight = root.getLeftNode().height();
        //获取根结点的右子树高度
        int rootRightHeight = root.getRightNode().height();
        //判断是左旋还是需要右旋还是不需要旋转
        int height = rootLeftHeight - rootRightHeight;
        //如果高度差小于 -1 表明右子树高度大且高度差 > 1，进行左旋
        if (height < -1) {
            //确定左旋判断是否需要双旋 ---> 右子结点的左子树的高度 > 右子树的高度 ---> 进行右旋
            int rootRightLeftHeight = 0;
            int rootRightRightHeight = 0;
            if (root.getRightNode().getLeftNode() != null)
                rootRightLeftHeight = root.getRightNode().getLeftNode().height();
            if (root.getRightNode().getRightNode() != null)
                rootRightRightHeight = root.getRightNode().getRightNode().height();
            //此时需要做双旋
            if (rootRightLeftHeight > rootRightRightHeight) root.doubleLeftRotate();
                //否则做左旋即可
            else root.leftRotate();
            System.out.println("树的高度：" + rootTreeHeight());
            System.out.println("左子树的高度：" + leftTreeHeight());
            System.out.println("右子树的高度：" + rightTreeHeight());
        }
        //如果高度差大于 1 表明左子树高度大且高度差 > 1，进行右旋
        else if (height > 1) {
            //确定右旋判断是否需要双旋 ---> 左子结点的右子树的高度 > 左子树的高度 ---> 进行左旋
            int rootLeftRightHeight = 0;
            int rootLeftLeftHeight = 0;
            if (root.getLeftNode().getRightNode() != null)
                rootLeftRightHeight = root.getLeftNode().getRightNode().height();
            if (root.getLeftNode().getLeftNode() != null)
                rootLeftLeftHeight = root.getLeftNode().getLeftNode().height();
            //此时需要做双旋
            if (rootLeftRightHeight > rootLeftLeftHeight) root.doubleRightRotate();
                //否则做右旋即可
            else root.rightRotate();
            System.out.println("树的高度：" + rootTreeHeight());
            System.out.println("左子树的高度：" + leftTreeHeight());
            System.out.println("右子树的高度：" + rightTreeHeight());
        }
        //不进行旋转
        else {
            //否则高度差不大于 1 不用进行旋转，本身就是平衡二叉树
            System.out.println("该二叉排序树本身就是一个平衡二叉树哦~");
            return;
        }
    }

    //获取整棵树的高度
    public int rootTreeHeight() {
        return root.height();
    }

    //获取左子树的高度
    public int leftTreeHeight() {
        return root.getLeftNode().height();
    }

    //获取右子树的高度
    public int rightTreeHeight() {
        return root.getRightNode().height();
    }
}

class AVLNode {
    private int value;
    private AVLNode leftNode;
    private AVLNode rightNode;

    public AVLNode(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public AVLNode getLeftNode() {
        return leftNode;
    }

    public void setLeftNode(AVLNode leftNode) {
        this.leftNode = leftNode;
    }

    public AVLNode getRightNode() {
        return rightNode;
    }

    public void setRightNode(AVLNode rightNode) {
        this.rightNode = rightNode;
    }

    @Override
    public String toString() {
        return "AVLNode[" +
                "value=" + value +
                ']';
    }

    //创建二叉排序树
    public void add(AVLNode avlNode) {
        //如果要添加的节点为空，直接返回
        if (null != avlNode) {
            //比较要添加节点的值和当前节点的值，如果小于当前节点，放在左边
            if (this.getValue() > avlNode.getValue()) {
                //如果左节点为空，则插入，如果不为空，则递归
                if (this.getLeftNode() == null) this.leftNode = avlNode;
                else this.getLeftNode().add(avlNode);
            } else {
                //如果大于等于当前值且右节点为空则放在右边
                if (this.getRightNode() == null) this.rightNode = avlNode;
                else this.getRightNode().add(avlNode);
            }
        }
        return;
    }

    //中序遍历
    public void infixOrder() {
        if (this.getLeftNode() != null) this.getLeftNode().infixOrder();
        System.out.print("[" + this.getValue() + "] ---> ");
        if (this.getRightNode() != null) this.getRightNode().infixOrder();
    }

    //查询要删除的结点
    public AVLNode search(int value) {
        //如果当前结点的值等于指定值 value 然后返回
        if (value != this.value) {
            //如果 value 比当前节点的值要小就往左边找
            if (value < this.value) {
                //如果左节点不为空就找，为空直接返回 null
                if (this.getLeftNode() == null) return null;
                else return this.getLeftNode().search(value);
            } else {
                //如果 value 比当前节点的值要大就往右边找
                if (this.getRightNode() == null) return null;
                else return this.getRightNode().search(value);
            }
        } else {
            return this;
        }
    }

    //查询要删除结点的父结点
    public AVLNode searchParent(int value) {
        //如果当前节点的左孩子或者右孩子结点的值与 value 相等，返回当前节点
        if ((value == this.getRightNode().getValue() && this.getRightNode() != null) || (this.getLeftNode() != null && value == this.getLeftNode().getValue()))
            return this;
        //否则的话比较 value 当前结点值看是往左边去还是往右边去
        if (this.getLeftNode() != null && value < this.getValue()) return this.getLeftNode().searchParent(value);
        else if (this.getRightNode() != null && value > this.getValue())
            return this.getRightNode().searchParent(value);
        else return null;
    }

    //获取当前结点的高度
    public int height() {
        return Math.max(this.leftNode == null ? 0 : this.leftNode.height(), this.rightNode == null ? 0 : this.rightNode.height()) + 1;
    }

    //左旋
    public void leftRotate() {
        //1. 与根结点值一样的新结点
        AVLNode newNode = new AVLNode(this.getValue());
        //2. 新结点的左指针指向根结点的左子树
        newNode.setLeftNode(this.getLeftNode());
        //3. 新结点的右指针指向根结点的右子结点的左子树
        newNode.setRightNode(this.getRightNode().getLeftNode());
        //4. 根结点的值赋值为根结点的右子结点的值
        this.setValue(this.getRightNode().getValue());
        //5. 根结点的右指针指向右子节点的右子树
        this.setRightNode(this.getRightNode().getRightNode());
        //6. 根结点的左指针指向新结点
        this.setLeftNode(newNode);
    }

    //右旋
    public void rightRotate() {
        //1. 创建一个新结点并赋值为根结点的值
        AVLNode newNode = new AVLNode(this.getValue());
        //2. 新结点的右指针指向根结点的右子树
        newNode.setRightNode(this.getRightNode());
        //3. 新结点的左指针指向根结点的左子节点的右子树
        newNode.setLeftNode(this.getLeftNode().getRightNode());
        //4. 左子结点的值赋值给根结点
        this.setValue(this.getLeftNode().getValue());
        //5.根结点的左指针指向左子节点的左子树
        this.setLeftNode(this.getLeftNode().getLeftNode());
        //6. 根结点的右指针指向新结点
        this.setRightNode(newNode);
    }

    //确定左旋的双旋 ---> 右子结点的左子树的高度和右子树的高度之间的高度差大于 1 ---> 右子结点右旋
    public void doubleLeftRotate() {
        //右子结点先右旋
        this.getRightNode().rightRotate();
        //然后根结点左旋
        this.leftRotate();
    }

    //确定右旋的双旋 ---> 左子结点的右子树的高度和左子树的高度之间的高度差大于 1 ---> 左子节点左旋
    public void doubleRightRotate() {
        //左子节点先左旋
        this.getLeftNode().leftRotate();
        //然后根结点右旋
        this.rightRotate();
    }
}
```

## 8. `23-Tree`

`23树`是`B树`的一种，只要是`B树`所有的叶子结点就都在同一层，`23树`的意思是一个节点有`2-3`个子树，一棵`23树`要么是棵空树，要么由以下节点组成：

1. `2-结点`：若不是叶子结点，则含有一个元素并且有两棵子树，左子树所有元素均小于它的父结点元素，右子树所有元素均大于它的父结点元素
2. `3-结点`：若不是叶子结点，则含有两个元素并且有三棵子树，左子树所有元素均小于它的父结点元素，中间子树所有元素均位于父结点两个元素值的中间即大于父结点左元素的值，可以将父结点左元素，父结点左子树，左边元素合并在一起看成是一棵二叉排序树，右子树所有元素均大于它的父结点元素

【注：子树要么是空树，要么也是`2-结点`或者`3-结点`】

## 9. `B-Tree`

1. 数据库的索引是用树来实现的，因为树的查找效率高并且可以保证有序，刚开始想的是使用二叉搜索树也就是二叉排序树或者也可以叫二叉查找树来实现数据库的索引，因为从算法角度上来说，二叉搜索树是全都在内存中完成的并且查找速度和比较次数都是最小的。

2. 但是，但是啊， 数据是存储在数据库中的，而这些数据持久化存储就少不了磁盘读写也就是`磁盘IO`，并且数据库索引是存储在磁盘上的，如果数据量比较大的时候，索引的大小可能有几个`G`甚至更多，当我们利用索引查询的时候显然不能把整个索引都加载到内存中，能做的就是把索引逐一加载到磁盘页中，这里的磁盘页对应着索引树的结点。

3. 假设树的高度是`4`，要查找的值是`10`，第一次读写磁盘的时候会先找到`9`，然后第二次找到`13`，第三次找到`11`，最后一次才找到`10`，总共`4`次，由此可以看出在二叉搜索树中，磁盘中的最差`IO`次数正好对应着树的高度。

4. 既然如此，减少磁盘读写次数的手段就在于减少树的高度，本来是“瘦高”的树变成”矮胖“的树，这就形成了`B-Tree`

5. `B-Tree`是一种多路平衡查找树，它的每一个结点最多包含`k`个孩子，`k`就是`B-Tree`的阶，其大小取决于磁盘页的大小

   ![](https://img-blog.csdnimg.cn/f93d5ed145f743aebe7889526cc00fdd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3JBY0tlUi0x,size_19,color_FFFFFF,t_70,g_se,x_16)

6. `B-Tree`有以下几个特征：

   - 根结点至少有两个子女
   - 每个中间结点都包含`k-1`个元素和`k`个孩子，其中`m /2 <= k <= m`
   - 每一个叶子结点都包含`k-1`个元素，其中`m / 2 <= k <= m`
   - 所有叶子结点都位于同一层
   - 每个结点中的元素从小到大排列，结点当中`k-1`个元素正好是`k`个孩子包含的元素的值域分化【这太他娘的抽象了】

   

B树的阶：所有结点中最多子结点的个数。比如：`2-3-Tree`的阶是`3`，而0`2-3-4-Tree`的阶是`4`

## 10. `B+Tree`

## 11. `B*Tree`